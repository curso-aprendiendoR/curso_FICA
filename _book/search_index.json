[["index.html", "APRENDIENDO R Introducción Metodología Propósito Contenido", " APRENDIENDO R Paola Guerrero Introducción El objetivo de este curso es introducir a todos los participantes al lenguaje de programación R, manejar diferentes variables, así como estructuras de control, finalmente comenzar el camino en el análisis geoestadístico. Este manual ha sido elaborado en R con bookdown.El código del curso se encuentra en GitHub Metodología Actividades prácticas mediante ejercicios que refuercen el aprendizaje del tema. Los estudiantes aprenderán haciendo y utilizando el lenguaje de programación R y el entorno de desarrollo RStudio Propósito El curso se ha planteado de manera que cumpla con dos propósitos fundamentales: Vencer el miedo a programar, y recordar siempre que los errores son solo eso, errores Empezar a trabajr con datos y generar autonomía propia en codificación. Contenido Antes de Empezar Primeros Pasos: Tipos de Variables y Lectura de datos Facilitando el problema: Flujo del Programa y Estructuras de Control Gráficos Interpolación Espacial y Mapas con R "],["instalación.html", "Capitulo1 Instalación 1.1 ¿Qué es R y Rstudio? 1.2 ¿Cómo los Instalo? 1.3 Intalación de Paquetes", " Capitulo1 Instalación 1.1 ¿Qué es R y Rstudio? R es un software libre especializado en la estadística y el análisis de datos; además es importante tener presente que R es un lenguaje de programación, es decir es nuestro idioma, nuestro español, con el que lograremos comunicarnos con el computador. La estructura de código abierto y la facilidad de compartir es una ventaja que permite tener flexibilidad y personalización, facilitando el desarrollo de paquetes y extensiones que amplían las capacidades de R. Ahora si decimos que R es el idioma que permite la comunicación, y que nuestra comunicación será escrita nos preguntaremos: ¿Cuál es el canal que nos permitirá comunicarnos? De la misma manera que el mismo texto en español puede ser escrito en una carta, un correo, un mensaje de texto, en programación se puede usar diferentes entornos de desarrollo integrado IDE, siendo nuestro IDE RStudio. 1.2 ¿Cómo los Instalo? Recuerda que tanto para instalar R, RStudio y algunos paquetes se necesita conexión a internet. 1.2.1 Empezaremos instalando R Para instalar R hay que ingresar en https://cran.r-project.org/ y seleccionar la instalación acorde al sistema operativo que uses. Para sistemas operativos Windows, hacer clik en install R for the first time En la siguiente pantalla hacer click en Download R for Windows. Actualmente la última versión disponible es: R-4.4.1 y solo se encuentra disponible para 64 bit. Una vez se haya descargado el instalador, lo ejecutamos haciendo doble click y seguimos los pasos de instalación predeteminados. 1.2.2 Instalación de RStudio Para instalar RStudio debe ingresar en https://posit.co/download/rstudio-desktop/#download y hacer click en Download RStudio Desktop for Windows Después de descargar el instalador, lo ejecutamos haciendo doble click y seguimos los pasos de instalación predeteminados. Finalmente, tras la instalación tendrás en el escritorio o en su defecto podrás buscar en la barra de tareas RStudio y estamos listos para empezar. Recuerda que aunque no vayamos a usar la consola de R; RStudio no se ejecutará a menos que hayas instalado previamente R Les dejo un video recopilado de Youtube, que puede servirles si aún no pueden intalar R y Rstudio 1.3 Intalación de Paquetes Cuando Instalamos R y Rstudio, se instalan 7 paquetes básicos con las funciones mínimas para poder operar. Sin embargo, recordemos que R es un software libre, por lo que existen códigos hechos por otros usuarios y validados por el equipo de CRAN, a este conjunto de funciones, datos y documentación sobre las funciones se les llama paquetes o librerías y podrán ser instalados según las necesidades. Actualmente existen 21254 paquetes que incrementan las potencialidades de R. Para ocupar una librería de R debe descargarse mediante install.packages(\"nombre de la librería\"), este proceso se realizará una sola vez. Una vez instalada la librería, debemos decirle a R que queremos utilizarla con library(\"nombre de la librería\"). Recuerda que siempre que inicies sesión será necesario acudir a la librería nuevamente. "],["interfaz-de-rstudio.html", "Capitulo2 Interfaz de RStudio 2.1 ¿ Y En dónde Programamos?", " Capitulo2 Interfaz de RStudio Consola: En la consola podemos ejecutar órdenes y también es la sección en donde se mostrarán los resultados. Figure 2.1: Consola de R Entorno de variables: Si observas la imagen anterior, se ha utilizado la consola como una calculadora, sin embargo, implicitamente hemos realizado un proceso muy importante en la programación, la asiganción, que consiste en almacenar un valor en una variable, cuando se asigna una variable se realiza una reserva de memoria. Para realizar una asignación en R se debe tener en cuenta tres elementos: El nombre de la variable El operador de asignación que puede ser: &lt;- o = El datos a asignar Practiquemos, en la consola escribiremos: a &lt;- 30 b = 12 ¿Pero en donde puedo visulaizar las variables que hemos creado? El panel de entorno es en donde se irán guardando los objetos con los que trabajemos. Figure 2.2: Entorno de R Archivos/Plots/Ayuda: Este cuadrante se encuentra en la parte inferior derecha de la pantalla y tiene varios paneles, entre ellos tenemos la pestaña Files en donde se muestran los documentos del directorio del proyecto en donde se está trabajando actualmente. En el panel también se tiene las pestañas: Plots en donde se mostrarán los gráficos resultantes, Packages los paquetes instalados, Heplen donde se podrá busrcar la documentación de las funciones. Figure 2.3: Panel de Archivos de R Además si se escribe en la consola ? Nombre de la función se activará el panel de ayuda con la información de la función ? read.csv Figure 2.4: Panel de Ayuda 2.1 ¿ Y En dónde Programamos? Recordemos que cuando hablábamos de RStudio, hacíamos el simil con el canal de comunicación, por lo que la última parte del interfaz que nos falta revisar es justamente en donde vamos a progamar. Así que abriremos un Script. Un Script no es más que un archivo de texto en el que se escribe las intrucciones para comunicarnos con R. ¿Podríamos comunicarnos a través de la consola? Si sin embargo cuando cierres RStudio, perderás todo. Vamos a abrir nuestro primer Script haciendo click en File&lt;&lt; New File&lt;&lt; R Script Tras abrirlo se desplegará una cuarta ventana en donde empezaremos a trabajar. Recuerda que este archivo se puede guardar tecleando Ctrl + s o haciendo click en Save current Documents Figure 2.5: Apertura de Script Figure 2.6: Script "],["variables.html", "Capitulo3 Variables 3.1 Variables Numéricas 3.2 Variable de tipo caracter (texto) 3.3 Variables Lógicas o Booleanas 3.4 Fechas 3.5  Ejercicio", " Capitulo3 Variables ¿Con qué tipo de datos podemos trabajar? R es un lenguaje de programación y entorno de desarrollo especializado en análisis estadístico, por lo que todo proceso lo basaremos en torno a variables matemáticas, sin embargo recordemos que una variable matemática puede ser un valor numérico o un valor no numérico. Por lo que en este capítulo se describirá diferentes tipo de variables que será de utilidad más adelante. 3.1 Variables Numéricas Las variables numéricas, son aquellas que representan números, sean entero como edad o decimales como la estatura y con ellas se pueden realizar operaciones aritméticas. Con los datos numéricos podemos realizar todas las operaciones matemáticas como: sumar (+), restar (-), multiplicar (*), dividir (/), obtener el resto de la división %%, la raíz cuadrada sqrt(), el valor absoluto abs(), obtener una potencia (^), etc. ## Asignando las variables a &lt;- 5 b &lt;- -2 #Suma - Resta - Multiplicación a + b #&gt; [1] 3 a - b #&gt; [1] 7 a*b #&gt; [1] -10 #División a/b #&gt; [1] -2.5 a%/%b #&gt; [1] -3 a%%b #&gt; [1] -1 #Potencia y raíz a^2 #&gt; [1] 25 sqrt(b) #&gt; Warning in sqrt(b): NaNs produced #&gt; [1] NaN # NaN es un número que no está definido sqrt(abs(b)) #&gt; [1] 1.414214 3.2 Variable de tipo caracter (texto) Dentro de las variables no numéricas, se encuentran las variables cualitativas, por ejemplo, el nombre de una persona o su estado civil. #Asignemos variables de tipo texto nombre = &quot;Lucía&quot; apellido &lt;- &quot;Álvarez&quot; Las variables ya están asignadas, y se pueden observar en el panel de entorno, pero no observamos ningún resultado. Vamos a imprimir el resultado y utilizaremos la función print(). #Impresión de resultados print(nombre) #&gt; [1] &quot;Lucía&quot; Las cadenas de texto son un tipo especial de dato, que no puede ser operada aritméticamente ya que no son datos numéricos, sin embargo se puede concatenar diferentes variables o varias cadenas de texto. Una de las opciones para concatenar es la función paste(). # Practiquemos edad &lt;- 31 paste(nombre, apellido,&quot;tiene&quot;, edad, &#39;años&#39;) #&gt; [1] &quot;Lucía Álvarez tiene 31 años&quot; Por default esta función agrega espacio por separador, sin embargo se puede configurar agregado ,sep=\"(el separador deseado)\" paste(nombre, apellido,&quot;tiene&quot;, edad, &#39;años&#39;, sep = &quot;-&quot;) #&gt; [1] &quot;Lucía-Álvarez-tiene-31-años&quot; 3.3 Variables Lógicas o Booleanas A la pregunta ¿usted tiene hermanos?, la respuesta será un variable lógica. Si tiene hermanos la respuesta será TRUE y FALSE si no tiene hermanos. a &lt; 8 #&gt; [1] TRUE b == 12 #&gt; [1] FALSE #Hagamos otro ejemplo #Vamos a crear una secuencia y después comprobaremos si un número está contenido en la secuencia c &lt;- 3:10 6%in%c #&gt; [1] TRUE # A la misma secuencia le preguntaremos si alguno de los elementos es 2 all(c == 2) #&gt; [1] FALSE Si tuvieramos dudas del tipo de variable con la que estamos trabajando podemos recurrir al comando class() class(a) #&gt; [1] &quot;numeric&quot; class(nombre) #&gt; [1] &quot;character&quot; 3.4 Fechas Uno de los tipos de datos a los que tal vez tengamos que enfrentarnos es a las fechas. Si observamos: 16-09-2024 podemos facilmente comprender que estamos hablando de un día, mes y año específico, es decir un instante en el tiempo con el que podríamos operar, podríamos sumar un día o restar un mes y seguir sabiendo que tenemos una fecha en concreto. Sin embargo para R 16-09-2024 esto es una cadena de texto que no tiene el mismo significado que nosotros le hemos dado fecha&lt;- &quot;2024-09-16&quot; class(fecha) #&gt; [1] &quot;character&quot; #Sumemos un día es decir 86400 segundos fecha + 86400 #&gt; Error in fecha + 86400: non-numeric argument to binary operator Entonces es necesario convertir una cadena de texto en Fecha, que aunque la seguiremos visualizando como un texto R la almacenará como un número, el número de segundos transcurridos desde el 1 de enero de 1970. Para realizar esta transformación solo se requiere del comando as.POSIXct() o como lista con el comando as.POSIXLT() f&lt;- as.POSIXct(&quot;2024-09-16 10:20&quot;) print(f) #&gt; [1] &quot;2024-09-16 10:20:00 -05&quot; f + 86400 #&gt; [1] &quot;2024-09-17 10:20:00 -05&quot; y ¿qué sucede si tengo mi fecha en otro formato? R no te entenderá y tendremos que explicarle cual es el formato que hemos ingresado # Ingresaré la fecha en el formato: día/año/año as.POSIXct(&quot;16/09/2024&quot;) #&gt; [1] &quot;0016-09-20 LMT&quot; #¿Cómo hago que R me comprenda? as.POSIXct(&quot;16/09/2024&quot;, format = &quot;%d/%m/%Y&quot;) #&gt; [1] &quot;2024-09-16 -05&quot; Una fecha se puede expresar de muchos formatos, y cada uno se codifica de manera diferente, puedes acceder a las ayudas de R para encontrar el formato que requieras ?as.POSIXct Tanto as.POSIXct, como as.POSIXlt, se encuentran dentro de los paquetes básicos de R, sin embargo también se cuenta con el paquete {lubridate} con diferentes funciones para trabajar con fechas. 3.5  Ejercicio El fin de semana salió a comer a un restaurante en donde la comida le costó $16, para obtener el valor total debe agregarle el impuesto del valor agregado del 15% y 5% de servicios y propina. Almacene en una variable llamada total el valor total cancelado. Imprima la frase: La comida ha costado: Si usted salió de su casa con $25, imprima una cadena de texto que exprese cuánto dinero le sobró Calcula los días y años que han pasado desde la fecha de tu cumpleaños hasta el día de hoy. "],["vectores.html", "Capitulo4 Vectores 4.1  Ejercicio", " Capitulo4 Vectores Hasta el momento hemos almacenado únicamete variables individuales. ¿Y si quisiéramos almacenar un conjunto de elementos? Los vectores en R son objetos que tienen una sola dimensión, en donde se puede almacenar diferentes tipos de variables. Para crear un vector en R se utiliza el comando c() y cada elemento que pertenecerá a este conjuno se debe separar con ,. Muchas veces será importante conocer la longitud total, tambien llamada dimensión del vector se utiliza el comando length(). # Ceración de un vector con variables numéricas v &lt;- c(3,5,9) # Vamos a agregar nombres a las posiciones de los valores v1 &lt;- c(3,5,9,ancho = 2, largo = 7) # ¿Cómo puedo imprimir un vector? print(v) #Opción 1 #&gt; [1] 3 5 9 (v1) #Opción 2 #&gt; ancho largo #&gt; 3 5 9 2 7 # Determinar la longitud o dimensión del vector length(v) #&gt; [1] 3 length(v1) #&gt; [1] 5 Es muy importante poder acceder a los objetos creados. En este capítulo repasaremos cómo ponder visualizar y modificar los elementos de un vector. Hay que recordar que la posisicón de los elemento de un vector comienzan en 1 y que dentro del corchete se debe colocar la posición del elemento a ser encontrado. obteniendo como resultado el valor del objeto que ocupa la posición consultada # Accederemos al primer elemento del vector llamado v1 v1[1] #&gt; #&gt; 3 #También podemos eliminar elementos del vector v[-2] #&gt; [1] 3 9 Sin embargo si yo intento buscar un elemento que está fuera de la longitud del vector, obtendré un NA v[7] #&gt; [1] NA Accederemos a una variable a través del nombre de que le asignamos a esta y la modificaremos v1[&quot;largo&quot;] #&gt; largo #&gt; 7 v1[&quot;largo&quot;]= 15 print(v1) #&gt; ancho largo #&gt; 3 5 9 2 15 Finalmente obtendremos información a partir de variables lógicas # Del vector v1 queremos saber los elementos que tiene asignado un valor mayor a 4 v1 &gt; 4 #&gt; ancho largo #&gt; FALSE TRUE TRUE FALSE TRUE Sin embargo no queremos conocer si la información es verdadera o falsa, queremos conocer el valor asigando a la respuesta verdadera mayor &lt;- v1 &gt; 4 v1[mayor] #&gt; largo #&gt; 5 9 15 Recuerda que los vectores no solo pueden contener variables numéricas, también podemos formar vectores con variables tipo caracter o variables lógicas. Ahora realizamos un ejercicio de práctica 4.1  Ejercicio Cree tres vectores, uno que corresponda a los nombres de las películas de Disney más influyentes, en otro asigne puntuaciones y finalmente uno de tipo lógico según el año de estreno de la película, en donde si esta se estrenó posterior al 2007 sea verdadero, caso contrario falso Figure 4.1: Películas de Disney Obtener el valor promedio de puntuaciones de las tres series, puede usar el comando mean() Almacene en un vector el nombre de la película mejor puntuada y la peor puntuada Almacene en un vector llamado pelis_viejitas las películas estrenadas antes del 2007, mediante variables lógicas Elimine del vector que almacena los nombres de las películas el nombre de la película con menor puntaje. "],["data-frames.html", "Capitulo5 Data Frames 5.1  Ejercicio", " Capitulo5 Data Frames Recordemos que un vector es un objeto en una sola dimensión, es decir hemos formados columnas independientes. En este capítulo formaremos datos estructurados a través de data frames. Los data frames son un cojunto de vectores de la misma longitud, sin embargo, no necesariamente del mismo tipo, lo que hace que tengan una vetaja sobre las matrices que son otro tipo de dato estructuraro de R que permiten almacenar distintas variables siempre y cuando tengan la misma longitud y el mismo tipo de dato.Esto es bastante limitante ya que en la vida real nuestros datos tendrán variables de todo tipo. Para crear data frames se utliza el comando data.frame() teniendo como argumento los vectores que queremos incluir, siempre separados por comas. Crearemos una tabla de datos de la nómina de estudiantes, este data frame está compuesto por variables de tipo caracter y variable tipo numéricas. # Crearemos una tabla de datos de la nómina de estudiantes nomina_estudiantes &lt;- data.frame(nombre= c(&quot;Ana&quot;,&quot;Lucía&quot;,&quot;Romina&quot;, &quot;Helena&quot;, &quot;Santiago&quot;, &quot;Joel&quot;), apellido = c(&quot;Cárdenas&quot;,&quot;Yépez&quot;,&quot;Lema&quot;,&quot;Torres&quot;,&quot;Campos&quot;,&quot;López&quot; ), edad =c(20,19,22,25,24,21)) print(nomina_estudiantes) #&gt; nombre apellido edad #&gt; 1 Ana Cárdenas 20 #&gt; 2 Lucía Yépez 19 #&gt; 3 Romina Lema 22 #&gt; 4 Helena Torres 25 #&gt; 5 Santiago Campos 24 #&gt; 6 Joel López 21 Observemos el data frame obtenido, miramos como cada vector ha formado una columna con el encabezado asignado, supongamos que queremos cambiar el encabezado de la columna (esta acción es muy común y bastante útil), utilizaremos el comando colnames(). colnames(nomina_estudiantes) &lt;- c(&#39;Nombre&#39;,&#39;Apellido&#39;,&quot;Edad&quot;) nomina_estudiantes #&gt; Nombre Apellido Edad #&gt; 1 Ana Cárdenas 20 #&gt; 2 Lucía Yépez 19 #&gt; 3 Romina Lema 22 #&gt; 4 Helena Torres 25 #&gt; 5 Santiago Campos 24 #&gt; 6 Joel López 21 Revisemos cuantas columnas y cuantas filas tenemos ncol(nomina_estudiantes) #&gt; [1] 3 nrow(nomina_estudiantes) #&gt; [1] 6 De la misma manera que podemos acceder a la información de un vector, podemos hacerlo en un data frame. Recordando los siguiente [fila,colunma] #Accederemos a la información de la primera fila, segunda columna nomina_estudiantes[1,2] #&gt; [1] &quot;Cárdenas&quot; #Seleccionar más de un elemnto del data frame nomina_estudiantes[2,c(2,3)] #&gt; Apellido Edad #&gt; 2 Yépez 19 nomina_estudiantes[2,c(&quot;Nombre&quot;,&quot;Apellido&quot;)] #&gt; Nombre Apellido #&gt; 2 Lucía Yépez nomina_estudiantes[c(1,3),c(1,3)] #&gt; Nombre Edad #&gt; 1 Ana 20 #&gt; 3 Romina 22 # Información de una columna nomina_estudiantes[,3] #&gt; [1] 20 19 22 25 24 21 #Podemos acceder a la información de una columan de manera rápida de la siguiente manera nomina_estudiantes$Apellido #&gt; [1] &quot;Cárdenas&quot; &quot;Yépez&quot; &quot;Lema&quot; &quot;Torres&quot; &quot;Campos&quot; #&gt; [6] &quot;López&quot; 5.1  Ejercicio Agregar una columna al data frame nomina_estudiantes llamada calificaciones, y regristre las siguientes calificaciones finales: 8.2, 5.4, 8.0, 7.5, 7.0, 6.2. Almacene en un data frame llamado orden_menor_a_mayor el regristro de estudiantes según la edad. Para ordenar utilice el comando order() busque información en la ayudas de R. Del data frame ordenado extraiga y almacene en una variable llamada Aprobados a las personas que obtuvieron mayor o igual a 7. No se olvide que se aprende a programar, programando por lo que debe pensar como codificar para que R sea quien identifique y extariga a quienes tienen más o igual a 7. "],["lectura-de-datos.html", "Capitulo6 Lectura de Datos 6.1  Ejercicio", " Capitulo6 Lectura de Datos En este capítulo revisaremos una tabla de datos extensa de la cual obtendremos varios resultados con varias herramientas que ya conocemos y algunas nuevas R contiene una librería con datos reales que pueden ser usados, para acceder a ella debemos instalar el paquete datasets y escribir el comando datasets::y pulsar el tabulador; esta librería te será muy útil para practicar. En esta clase no utilizaremos los datos de la librería de R, sino que cargaremos un documento tipo csv de datos de becarios del SENECYT. Para cargar datos csv en R escribimos el comando read.csv(), en el argumento colocaremos el directorio del archivo, sin embargo si el archivo se encuentra en la misma carpeta del proyecto basta con colocar el nombre del archivo y la extensión del mismo. Ahora si el archivo de datos es de tipo xlsx primero deberás instalar el paquete readxl y ejecutar el comando read_excel() #Carguemos y almacenemos el archivo incendio&lt;- read.csv(&quot;./documentos/maate_incendio.csv&quot;) Si queremos observar la tabla de datos podemos acceder a través del panel de entorno o con el comando View() View(incendio) Si quisiéramos ver parcialmente la información que tenemos podemos visualizar las 6 primeras filas de datos con el comando head(), también podemos visualizar las 6 últimas filas con el comando tail(). # Visualización de las 6 primeras filas de datos head(incendio) #&gt; ANIO_REPORT DPA_PROVIN PROVINCIA DPA_CANTON CANTON #&gt; 1 2022 17 PICHINCHA 1701 QUITO #&gt; 2 2022 17 PICHINCHA 1701 QUITO #&gt; 3 2022 17 PICHINCHA 1701 QUITO #&gt; 4 2022 17 PICHINCHA 1702 CAYAMBE #&gt; 5 2022 11 LOJA 1101 LOJA #&gt; 6 2022 7 EL ORO 705 CHILLA #&gt; DPA_PARROQ PARROQUIA EVENTO CAT_EVENTO #&gt; 1 170175 PIFO INCENDIO FORESTAL Antropico #&gt; 2 170175 PIFO INCENDIO FORESTAL Antropico #&gt; 3 170175 PIFO INCENDIO FORESTAL Antropico #&gt; 4 170252 CANGAHUA INCENDIO FORESTAL Antropico #&gt; 5 110151 CHANTACO INCENDIO FORESTAL Antropico #&gt; 6 70550 CHILLA INCENDIO FORESTAL Epoca seca #&gt; ALERTA_FECHA MES NIVEL_INF CALIF_EVEN CAT_CRUCE #&gt; 1 9/19/2021 9 Nivel 1 Nivel 1 aph #&gt; 2 9/10/2021 9 Nivel 1 Nivel 1 aph #&gt; 3 9/24/2021 9 Nivel 1 Nivel 1 aph #&gt; 4 9/23/2021 9 Nivel 2 Nivel 2 aph #&gt; 5 9/14/2021 9 Nivel 3 Nivel 1 bvp #&gt; 6 8/27/2021 8 Nivel 3 Nivel 2 bvp #&gt; NAM AREA_HA #&gt; 1 PONCE PALUGUILLO 10 #&gt; 2 PONCE PALUGUILLO 100 #&gt; 3 PONCE PALUGUILLO 10 #&gt; 4 KAYAMBI 20 #&gt; 5 CUENCA DEL RIO MALACATOS EN LOJA 140 #&gt; 6 CASACAY 140 #Visualización de las últimas 6 filas y columnas 7, 9 y 16 tail(incendio[,c(7,9,16)]) #&gt; PARROQUIA CAT_EVENTO AREA_HA #&gt; 58 SAN JOSE Antropico 1230 #&gt; 59 SAN MIGUEL Antropico 10 #&gt; 60 SAN MIGUEL Antropico 1500 #&gt; 61 CAYAMBE Antropico 100 #&gt; 62 TUFINO Antropico 750 #&gt; 63 TUFINO Antropico 750 El comando summary() es una excelente manera de hacer una inspección inicial de una base de datos, este comando permite obtener un resumen de la información a través de un reporte de estadística descriptiva summary(incendio) #&gt; ANIO_REPORT DPA_PROVIN PROVINCIA #&gt; Min. :2022 Min. : 1.000 Length:63 #&gt; 1st Qu.:2022 1st Qu.: 3.000 Class :character #&gt; Median :2022 Median : 9.000 Mode :character #&gt; Mean :2022 Mean : 9.651 #&gt; 3rd Qu.:2022 3rd Qu.:17.000 #&gt; Max. :2022 Max. :18.000 #&gt; #&gt; DPA_CANTON CANTON DPA_PARROQ #&gt; Min. : 101 Length:63 Min. : 10154 #&gt; 1st Qu.: 302 Class :character 1st Qu.: 30252 #&gt; Median : 901 Mode :character Median : 90112 #&gt; Mean : 967 Mean : 96747 #&gt; 3rd Qu.:1701 3rd Qu.:170160 #&gt; Max. :1808 Max. :180856 #&gt; #&gt; PARROQUIA EVENTO CAT_EVENTO #&gt; Length:63 Length:63 Length:63 #&gt; Class :character Class :character Class :character #&gt; Mode :character Mode :character Mode :character #&gt; #&gt; #&gt; #&gt; #&gt; ALERTA_FECHA MES NIVEL_INF #&gt; Length:63 Min. : 2.000 Length:63 #&gt; Class :character 1st Qu.: 8.000 Class :character #&gt; Mode :character Median : 9.000 Mode :character #&gt; Mean : 8.683 #&gt; 3rd Qu.:10.000 #&gt; Max. :12.000 #&gt; #&gt; CALIF_EVEN CAT_CRUCE NAM #&gt; Length:63 Length:63 Length:63 #&gt; Class :character Class :character Class :character #&gt; Mode :character Mode :character Mode :character #&gt; #&gt; #&gt; #&gt; #&gt; AREA_HA #&gt; Min. : 10.0 #&gt; 1st Qu.: 10.0 #&gt; Median : 10.0 #&gt; Mean : 112.7 #&gt; 3rd Qu.: 30.0 #&gt; Max. :1500.0 #&gt; NA&#39;s :4 Ahora revisemos la dimensión de la tabla de datos dim(). ¿Cuántos registos tengo (número de filas) nrow() y cuantas variables registradas (número de columnas) ncol()? y ¿si quiesiera saber el nombre de las variables colnames()? dim(incendio) #&gt; [1] 63 16 nrow(incendio) #&gt; [1] 63 ncol(incendio) #&gt; [1] 16 colnames(incendio) #&gt; [1] &quot;ANIO_REPORT&quot; &quot;DPA_PROVIN&quot; &quot;PROVINCIA&quot; #&gt; [4] &quot;DPA_CANTON&quot; &quot;CANTON&quot; &quot;DPA_PARROQ&quot; #&gt; [7] &quot;PARROQUIA&quot; &quot;EVENTO&quot; &quot;CAT_EVENTO&quot; #&gt; [10] &quot;ALERTA_FECHA&quot; &quot;MES&quot; &quot;NIVEL_INF&quot; #&gt; [13] &quot;CALIF_EVEN&quot; &quot;CAT_CRUCE&quot; &quot;NAM&quot; #&gt; [16] &quot;AREA_HA&quot; Ahora modifiquemos nuestro data frame de ejemplo para dejar únicamente las variables más relevantes Vamos a eliminar todos los datos de la operadora y practicaremos varias maneras de realizarlo. # Vamos con la más sencilla incendio&lt;- incendio[,-11] Ahora practicaremos un comando de mucha utilidad which() este comando nos permite encontrar índices (es decir el número de orden) correspondientes a variables que cumplan con ciertas caracteríticas. which(colnames(incendio)==&quot;DPA_PROVIN&quot;) #&gt; [1] 2 #Ahora vamos a eliminar esta columna #Primero almacenaré el índice de la variable a eliminar borrar&lt;- which(colnames(incendio)==&quot;DPA_PROVIN&quot;) #Ahora eliminamos la columna DPA_PROVIN incendio&lt;- incendio[,-borrar] Ahora eliminaremos las columnas que en el nombre tengan la palabra OPERADORA. Utilizaremos el comando grepl(), este comando busca comulnas con una caracteritica especifica, en el argumento colocaremos dos items: 1. El patrón a buscar 2. En donde buscarmenos el patrón grepl nos dará como resultado una veariable lógica indicándonos si cumple o no con la condición. Si observas bien el caso en el que borramos la columna TIPO_OPERADORA, te darás cuenta que antes de encontrar el índice encontramos un valor lógico. De manera similar realizaremos este caso #Vamos paso a paso #Primero obtendremos la variable lógica grepl(&quot;dpa&quot;, colnames(incendio), ignore.case =TRUE) #&gt; [1] FALSE FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE #&gt; [10] FALSE FALSE FALSE FALSE FALSE #He colocado un tercer item para indicar que no considere mayúsculas y minúsculas #Ahora buscaremos el indicador y lo almacenaremos borrar_2&lt;- which(grepl(&quot;dpa&quot;,colnames(incendio), ignore.case = TRUE)) #Finalmente lo eliminaremos incendio&lt;- incendio[,-borrar_2] #Hasta ahora el data frame se ve así head(incendio) #&gt; ANIO_REPORT PROVINCIA CANTON PARROQUIA EVENTO #&gt; 1 2022 PICHINCHA QUITO PIFO INCENDIO FORESTAL #&gt; 2 2022 PICHINCHA QUITO PIFO INCENDIO FORESTAL #&gt; 3 2022 PICHINCHA QUITO PIFO INCENDIO FORESTAL #&gt; 4 2022 PICHINCHA CAYAMBE CANGAHUA INCENDIO FORESTAL #&gt; 5 2022 LOJA LOJA CHANTACO INCENDIO FORESTAL #&gt; 6 2022 EL ORO CHILLA CHILLA INCENDIO FORESTAL #&gt; CAT_EVENTO ALERTA_FECHA NIVEL_INF CALIF_EVEN CAT_CRUCE #&gt; 1 Antropico 9/19/2021 Nivel 1 Nivel 1 aph #&gt; 2 Antropico 9/10/2021 Nivel 1 Nivel 1 aph #&gt; 3 Antropico 9/24/2021 Nivel 1 Nivel 1 aph #&gt; 4 Antropico 9/23/2021 Nivel 2 Nivel 2 aph #&gt; 5 Antropico 9/14/2021 Nivel 3 Nivel 1 bvp #&gt; 6 Epoca seca 8/27/2021 Nivel 3 Nivel 2 bvp #&gt; NAM AREA_HA #&gt; 1 PONCE PALUGUILLO 10 #&gt; 2 PONCE PALUGUILLO 100 #&gt; 3 PONCE PALUGUILLO 10 #&gt; 4 KAYAMBI 20 #&gt; 5 CUENCA DEL RIO MALACATOS EN LOJA 140 #&gt; 6 CASACAY 140 Recordemos que cuando observamos el resumen de variables nos indicaba que la fecha es tipo caracter, vamos a cambiar a tipo fecha, agregaremos una columna de hora que importaremos de un archivo csv y uniremos estas dos variables en una sola columna. Aquí practicaremos como agregar una nueva columna al data frame, uniremos dos datos en una sola columna, transformaremos a fecha y eliminaremos las columnas que ya han sido unificadas. #cargamos un archivo tipo csv en un nuevo data frame Hora&lt;-read.csv(&quot;./documentos/hora.csv&quot;, header = FALSE) #Unimos dos data frame incendio&lt;- cbind(incendio,Hora) #Cambiamos el nombre de la columna agregada colnames(incendio)[13]&lt;- &quot;ALERTA_HORA&quot; incendio$Fecha_Hora&lt;-paste(incendio$ALERTA_FECHA, incendio$ALERTA_HORA) incendio$Fecha_Hora&lt;- as.POSIXct(incendio$Fecha_Hora, format= &quot;%m/%d/%Y %H:%M:%OS&quot;) #Borraremos las columnas que ya no necesitamos incendio&lt;- incendio[,which(!grepl(&quot;ALERTA&quot;,colnames(incendio)))] Observe que cuando eliminamos las columnas de fecha y hora, a la estructura le agregamos ! y si somos observadores también identificaremos que quitamos -; esto se debe a que el signo ! es utilizado como negación. ¿Cómo ha quedado el data frame hasta el momento? head(incendio) #&gt; ANIO_REPORT PROVINCIA CANTON PARROQUIA EVENTO #&gt; 1 2022 PICHINCHA QUITO PIFO INCENDIO FORESTAL #&gt; 2 2022 PICHINCHA QUITO PIFO INCENDIO FORESTAL #&gt; 3 2022 PICHINCHA QUITO PIFO INCENDIO FORESTAL #&gt; 4 2022 PICHINCHA CAYAMBE CANGAHUA INCENDIO FORESTAL #&gt; 5 2022 LOJA LOJA CHANTACO INCENDIO FORESTAL #&gt; 6 2022 EL ORO CHILLA CHILLA INCENDIO FORESTAL #&gt; CAT_EVENTO NIVEL_INF CALIF_EVEN CAT_CRUCE #&gt; 1 Antropico Nivel 1 Nivel 1 aph #&gt; 2 Antropico Nivel 1 Nivel 1 aph #&gt; 3 Antropico Nivel 1 Nivel 1 aph #&gt; 4 Antropico Nivel 2 Nivel 2 aph #&gt; 5 Antropico Nivel 3 Nivel 1 bvp #&gt; 6 Epoca seca Nivel 3 Nivel 2 bvp #&gt; NAM AREA_HA #&gt; 1 PONCE PALUGUILLO 10 #&gt; 2 PONCE PALUGUILLO 100 #&gt; 3 PONCE PALUGUILLO 10 #&gt; 4 KAYAMBI 20 #&gt; 5 CUENCA DEL RIO MALACATOS EN LOJA 140 #&gt; 6 CASACAY 140 #&gt; Fecha_Hora #&gt; 1 2021-09-19 01:15:12 #&gt; 2 2021-09-10 16:20:21 #&gt; 3 2021-09-24 10:28:11 #&gt; 4 2021-09-23 05:21:08 #&gt; 5 2021-09-14 17:13:52 #&gt; 6 2021-08-27 18:33:30 summary(incendio) #&gt; ANIO_REPORT PROVINCIA CANTON #&gt; Min. :2022 Length:63 Length:63 #&gt; 1st Qu.:2022 Class :character Class :character #&gt; Median :2022 Mode :character Mode :character #&gt; Mean :2022 #&gt; 3rd Qu.:2022 #&gt; Max. :2022 #&gt; #&gt; PARROQUIA EVENTO CAT_EVENTO #&gt; Length:63 Length:63 Length:63 #&gt; Class :character Class :character Class :character #&gt; Mode :character Mode :character Mode :character #&gt; #&gt; #&gt; #&gt; #&gt; NIVEL_INF CALIF_EVEN CAT_CRUCE #&gt; Length:63 Length:63 Length:63 #&gt; Class :character Class :character Class :character #&gt; Mode :character Mode :character Mode :character #&gt; #&gt; #&gt; #&gt; #&gt; NAM AREA_HA #&gt; Length:63 Min. : 10.0 #&gt; Class :character 1st Qu.: 10.0 #&gt; Mode :character Median : 10.0 #&gt; Mean : 112.7 #&gt; 3rd Qu.: 30.0 #&gt; Max. :1500.0 #&gt; NA&#39;s :4 #&gt; Fecha_Hora #&gt; Min. :2021-02-13 06:49:19.00 #&gt; 1st Qu.:2021-08-05 07:44:18.00 #&gt; Median :2021-09-09 13:35:15.00 #&gt; Mean :2021-09-05 18:19:12.97 #&gt; 3rd Qu.:2021-10-06 14:08:17.50 #&gt; Max. :2021-12-28 18:28:36.00 #&gt; Al observar el resumen del data frame, observamos que el la columna de área tenemos a NA, estos casilleros no tiene datos. Ahora supongamos que queremos eliminar las filas que no tienen datos de área afectada. (Ojo: No siempre se deberá borrar las filas que no tienen datos, dependerá del análisis que se quiera hacer) incendio&lt;- na.omit(incendio) Para el manejo de data frame tenemos una herramienta muy potente: la función subset(). Dicha función permitir seleccionar filas y columnas a la vez, de la siguiente manera: x: Data frame de entrada. subset: condición lógica que queramos usar para seleccionar las filas. select: un vector que contenga el nombre de las columnas que queremos seleccionar (este argumento es necesario si queremos filtrar filas y columnas). En nuestro ejemplo vamos a buscar datos de la provincia y el cantón que tengan área de afectación mayor a 5 kilómetros cuadraros y que estas áreas afectadas sean parte del Sistema Nacional de Áreas Protegidas snap. #Primero pasameros de HA a km2 incendio$AREA_KM2 = incendio$AREA_HA * 0.01 #Ahora obtenemos los datos solicitados subset(incendio, subset = AREA_KM2 &gt; 5 &amp; CAT_CRUCE == &quot;snap&quot;, select = c(PROVINCIA, CANTON)) #&gt; PROVINCIA CANTON #&gt; 56 GUAYAS GUAYAQUIL #&gt; 58 TUNGURAHUA SANTIAGO DE PILLARO #&gt; 60 COTOPAXI SALCEDO #&gt; 62 CARCHI TULCAN 6.1  Ejercicio Del paquete datasets almacene el conjunto de datos llamado airquality y obtenga los siguientes resultados. (Recuerde utilizar las herramientas que hemos aprendido, tambíen puede buscar otro camino, pero siempre a través de codificación) En un data frame llamado calidad_mayo extraiga las 6 variables medidas para el mes de mayo. Elimine del data frame calidad_mayo las filas que contengan NA en cualquiera de las variables De la información que le quedó en calidad_mayo alamacene unicamente las filas en donde la velocidad el viento sea mayor a 10 y la temperatura menor a 70. Calcule cuantas filas quedaron descartadas después de depurar la información de mayo. Traduzque y Cambie los nombres de las columnas del data frame final de calidad_mayo Añada a los datos de mayo una columna con la fecha completa (recuerde que todas las observaciones son del año es del año 1973) "],["funciones-básicas.html", "Capitulo7 Funciones básicas 7.1 ¿Qué es una función? 7.2 Como armo una función 7.3 Creemos nuestra primera función 7.4  Ejercicio", " Capitulo7 Funciones básicas 7.1 ¿Qué es una función? Una función es un conjunto de instrucciones, de esta forma, es posible escribir un bloque de código y ejecutarlo para distintos datos. Una ventaja de utilizar funciones dentro de nuestra codificación es que nos ayuda a resolver un problema complejo descomponiendolo en problemas más pequeños. Así, en lugar de utilizar un programa muy grande para resolver un problema complejo se emplean distintos subprogramas que resuelven tareas sencillas. 7.2 Como armo una función Para crear una función se usa la palabra function y se debe tener dos componentes muy importantes: 1. Los parámetros: los parámetros son los “datos” de entrada que empleará la función y lo pongo entre comillas por que a estos parámetros aun no se les ha asignado datos, son solo nombres que posteriormente ocuparán la información que queramos operar. ¿Suena enredoso? Si un poco, pero tranquilos solo son conconceptos que con la práctica se vuelve más sencillo. Los parámetros en una función debe ir entre paréntesis y separados por comas. 2.Después viene el código de la función entre {} Y listo empecemos 7.3 Creemos nuestra primera función Empecemos con una función muy facil y que si bien es cierto no es necesaria nos sirve de práctica. suma&lt;- function(a,b) # estas son las variables { #Esto es lo que hace la función c&lt;- a+b return(c) # return no sirve para imprimir } Listo hemos creado la función y la hemos almacenado en una variable llamada suma Ahora la ejecutaremos suma(5,7) #&gt; [1] 12 Y listo, o casi. Poco a poco iremos avanzando en el uso de funciones 7.4  Ejercicio Cree una función que sirva para calcular el área, almacene el resultado en una variable e imprima esta variable. Luego ejecute la función con los valores de largo 4 y ancho 12. "],["condicional-if---else.html", "Capitulo8 Condicional IF - ELSE 8.1 IF - ELSE anidados 8.2 ifelse() Vectorizado 8.3  Ejercicio", " Capitulo8 Condicional IF - ELSE La estructura if - else es un conjunto de dos parámetros: la condición y la instrucción si la condición no se cumple. ESto nos permite tener dos indicaciones una cuando la condición si se cumple y una cuando no. Vamos a realizar un ejercicio en donde ocuparemos el condicional IF - ELSE y una función operar&lt;- function(a,b,operacion =&quot;suma&quot;){ # Esta llave abre la indicación de la función if(operacion == &quot;suma&quot;){ # Verdadero si operación es igual a la palabra suma c&lt;- a+b } else{# Falso si la palabra no corresponde a suma c&lt;- NA } return(c) } operar(5,7,operacion=&quot;suma&quot;) #&gt; [1] 12 operar(5,7, operacion = &quot;resta&quot;) #&gt; [1] NA 8.1 IF - ELSE anidados La estructura de control if - else puede anidarse, es decir puede concatenarse para obtener instrucciones y acciones más complejas operacion_a_b&lt;-function(a,b,operacion=&#39;suma&#39;){ if(operacion==&#39;suma&#39;){# Si operacion es igual a suma c&lt;-a+b }else if(operacion==&#39;resta&#39;){ # Si operacion no es igual a suma y es igual a resta c&lt;- a-b }else if(startsWith(operacion,&#39;multi&#39;)) { # Si la operación no es igual a resta y si cumple la condición c&lt;-a*b }else{ # Si operacion no cumple la condición c&lt;-NA } c } Hemos agregado al código el comando startWith()que permite determinar una cadena de texto que comience con los caracteres indicados, veamos como funciona este comando y la estructura de control anidada operacion_a_b(5,7,operacion=&#39;resta&#39;) #&gt; [1] -2 operacion_a_b(5,7,operacion=&#39;suma&#39;) #&gt; [1] 12 operacion_a_b(5,7,operacion=&#39;multiplicaremos&#39;) #&gt; [1] 35 operacion_a_b(5,7,operacion=&#39;xxmultiplicaremos&#39;) #&gt; [1] NA operacion_a_b(5,7,operacion=&#39;multiplica&#39;) #&gt; [1] 35 #Declaremos las variables previamente - Es decir coloquemos información en las variables a&lt;-5 b&lt;-3 paste(&#39;La suma de a + b es:&#39;,operacion_a_b(a,b,operacion = &quot;suma&quot;)) #&gt; [1] &quot;La suma de a + b es: 8&quot; paste(&#39;La resta de a - b es:&#39;,operacion_a_b(a,b,operacion=&#39;resta&#39;)) #&gt; [1] &quot;La resta de a - b es: 2&quot; 8.2 ifelse() Vectorizado ¿Que significa vectorizar una estructura condicional? Cuando vectorizamos podemos construir en una sola fila un número elevado de estructuras de condición, por lo que los argumentos de la función ifelse() seguirán el orden: (condición, que sucede si se cumple, que sucede si no se cumple). suma_resta&lt;-function(a,b,operacion=&#39;suma&#39;){ ifelse(operacion==&quot;suma&quot;,a+b, ifelse(operacion==&#39;resta&#39;,a-b,NA)) } suma_resta(5,9,operacion=&#39;resta&#39;) #&gt; [1] -4 suma_resta(5,9,operacion=&#39;mult&#39;) #&gt; [1] NA 8.3  Ejercicio Con la data empleada en el ejercicio del capítulo Lectura de Datos realice lo siguiente: Guarde en una variable llamada temperatura_alta un indicador lógico TRUE si alguno de los datos es mayor a 100 Farenheit, además escriba en la pantalla “Alguno de los registros supera los 100 F”, si no fuera el caso, guardar en la variable FALSE e imprimir “Ningún registo supera los 100F” "],["estructuras-de-control-bucles.html", "Capitulo9 Estructuras de Control: Bucles 9.1 For 9.2 While 9.3  Ejercicio", " Capitulo9 Estructuras de Control: Bucles Los bucles o ciclos, son herramientas de contro, que permiten repetir un fragmento de código bajo el cumplimiento de una condición, los bucles nos permiten tener eficiencia en tareas reincidentes o iterativas. En el curso revisaremos dos tipos de estructuras de control 9.1 For For nos permite repetir un conjunto de órdenes un numero establecido de veces a través de un índice irá recorriendo y ejecutanto el código que se encuentre dentro de las llaves. Con un ejemplo simple veamos el funcionamiento de este bucle. Observe que dentro del paréntesis se ha colocado el contador (en el ejemplo lo llamamos i) y la condición del número finito de veces que se repita 1:10, ahora en el corchete hemos colocado la instrucción print(i)es decir le hemos indicado que imprima el controlador. En el resultado observaremos que el controlador cada que se repetía el bucle incrementaba hasta llegar a 10 for(i in 1:10){ print(i) } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 #&gt; [1] 6 #&gt; [1] 7 #&gt; [1] 8 #&gt; [1] 9 #&gt; [1] 10 Ahora veamos un ejempo aplicativo Descargaremos de la bolsa el valor de las acciones de algunas empresas y resolveremos la pregunta: ¿ Cual es la empresa con mejor rendimiento? Entendiendo como rendimiento a: precio_cierre/precio_apertura # Instalaremos el paquete &quot;quantmod&quot; # Este paquete permite descargar valores de la bolsa #install.packages(&quot;quantmod&quot;) #Descomentar para instalar library(quantmod) # Obtengamos los valores para TSLA start &lt;- as.Date(&#39;2020-01-01&#39;) #Fecha de incio # getSymbols es una función del paquete quantmod que permite descargar y guardar TSLA &lt;- getSymbols(&#39;TSLA&#39;,src=&#39;yahoo&#39;,from=start, auto.assign = F) head(TSLA) #&gt; TSLA.Open TSLA.High TSLA.Low TSLA.Close #&gt; 2020-01-02 28.30000 28.71333 28.11400 28.68400 #&gt; 2020-01-03 29.36667 30.26667 29.12800 29.53400 #&gt; 2020-01-06 29.36467 30.10400 29.33333 30.10267 #&gt; 2020-01-07 30.76000 31.44200 30.22400 31.27067 #&gt; 2020-01-08 31.58000 33.23267 31.21533 32.80933 #&gt; 2020-01-09 33.14000 33.25333 31.52467 32.08933 #&gt; TSLA.Volume TSLA.Adjusted #&gt; 2020-01-02 142981500 28.68400 #&gt; 2020-01-03 266677500 29.53400 #&gt; 2020-01-06 151995000 30.10267 #&gt; 2020-01-07 268231500 31.27067 #&gt; 2020-01-08 467164500 32.80933 #&gt; 2020-01-09 426606000 32.08933 analizadas&lt;- c(&#39;AMZN&#39;,&#39;AAPL&#39;,&#39;GOOG&#39;, &#39;TSLA&#39;, &#39;NFLX&#39;) for(empresa in analizadas){ data_empresas&lt;-getSymbols(empresa,src=&#39;yahoo&#39;,from=start, to=Sys.Date(), auto.assign = F) df_empresas&lt;- as.data.frame(data_empresas) precio_apertura&lt;- df_empresas[1,1] precio_actual&lt;- df_empresas[nrow(df_empresas),6] rendimiento&lt;- precio_actual/precio_apertura} rendimiento #&gt; [1] 2.137565 ¿De quíen es este rendimiento, es de la mejor empresa? NO el resultado que obtuvimos es el rendimiento de la última empresa que analizó el bucle es decir de Netflix Pero cómo hago que me devuelva no la última si no la mejor. Vamos a poner un condicional que evalue si el resultado anterior es mejor o peor que el anterior y así me determine el mejor de lo mejor. analizadas&lt;- c(&#39;AMZN&#39;,&#39;AAPL&#39;,&#39;NFLX&#39;,&#39;GOOG&#39;, &#39;TSLA&#39;) calcula_rendimiento&lt;- function(empresas,fecha_inicio,fecha_fin=Sys.Date()){ mejor_rendimiento&lt;- -Inf mejor_empresa&lt;- NA for(empresa in analizadas){ data_empresas&lt;-getSymbols(empresa,src=&#39;yahoo&#39;,from=fecha_inicio, to=fecha_fin, auto.assign = F) df_empresas&lt;- as.data.frame(data_empresas) precio_apertura&lt;- df_empresas[1,1] precio_actual&lt;- df_empresas[nrow(df_empresas),6] rendimiento&lt;- precio_actual/precio_apertura if(rendimiento&gt;mejor_rendimiento){ mejor_rendimiento&lt;- rendimiento mejor_empresa&lt;- empresa }} list(empresa=mejor_empresa,rendimiento =round((mejor_rendimiento)*100),2) } Ahora generemos resultados ¿Cuál es la empresa con mejor rendimiento del 2020? resul&lt;- calcula_rendimiento(analizadas,fecha_inicio=&#39;2020-01-01&#39;,fecha_fin= &#39;2020-12-31&#39;) paste(&#39;La empresa con mejor rendimiento fue:&#39; ,resul[[&#39;empresa&#39;]], &#39;y su rendimiento fue de&#39; , resul[[&#39;rendimiento&#39;]],&#39;%&#39;) #&gt; [1] &quot;La empresa con mejor rendimiento fue: TSLA y su rendimiento fue de 818 %&quot; ¿Cuál es la empresa con mejor rendimiento desde 2021 hasta la actualidad? resul_2&lt;- calcula_rendimiento(analizadas,fecha_inicio=&#39;2021-01-01&#39;) paste(&#39;La empresa con mejor rendimiento fue:&#39; ,resul_2[[&#39;empresa&#39;]], &#39;y su rendimiento fue de&#39; , resul_2[[&#39;rendimiento&#39;]],&#39;%&#39;) #&gt; [1] &quot;La empresa con mejor rendimiento fue: GOOG y su rendimiento fue de 180 %&quot; 9.2 While Este es un tipo de bucle que ocurre mientras una condición es verdadera TRUE Hagamos un ejercicio mientras aprendemos varias cosas extra Respondamos las pregunta: ¿ Cúantas iteraciones debemos hacer hasta obtener un número menor a 5? Dentro de R podemos trabajar con varias distribuciones, con la función r acompañada del nombre de la distribución podemos generar valores aleatorios, el primer argumento de la función runif() es cuantos números queremos generar, el segundo es el valor mínimo del número aleatorio, y el tercer argumento, el valor máximo. val&lt;- 1 # Observe que estamos declarando una variable previamente al incio del bucle while(val&lt;5){ val&lt;-runif(1,min = 0,max = 10) print(val) } #&gt; [1] 0.9981199 #&gt; [1] 2.966165 #&gt; [1] 7.334744 Ahora que ya hemos entendido el funcionamiento del bucle While hagamos un ejemplo: Determine el factor de fricción, mediante la ecuación de Colebrook White, para una tubería de PVC de 250 mm por el que transita un caudal de 55 l/s Les colocaré todas las ecuaciones necesarias Figure 9.1: Ecuación de Colebrook White Figure 9.2: Número de Reynolds Figure 9.3: Ecuación de la Continuidad # Datos Q&lt;- 0.055 # Caudal D&lt;- 0.25 # Diámetro e&lt;- 0.0000015 # Rugosidad absoluta vis&lt;- 1.007*(10^-6) # Viscosidad A&lt;- (pi*(D^2))/4 # Área Re&lt;- ((Q/A)*D)/vis #Número de Reynolds #Controladores f&lt;- 1 f_anterior&lt;- 0.02 f_nuevo&lt;- 0.01 while(f != f_nuevo){ f_nuevo&lt;- (1/(-2*log10(((e/D)/3.71)+(2.5/(Re*sqrt(f_anterior))))))^2 if(f_nuevo == f_anterior){ f&lt;- f_nuevo} else{ f_anterior&lt;- f_nuevo } } f #&gt; [1] 0.01472123 9.3  Ejercicio Para un canal abierto rectangular de PVC (e = 0.0015x10-3). La profundidad del flujo uniforme es 0.5 m con un ancho de 10 m y pendiente de 0.000035. Calcular el caudal que transita En la carpeta documentos puede encontrar el ejercicio resuelto para que le sirva como guía de programación. "],["funciones-de-la-familia-apply.html", "Capitulo10 Funciones de la familia Apply 10.1 lapply 10.2 sapply 10.3 Practiquemos 10.4 apply", " Capitulo10 Funciones de la familia Apply La familia apply en un conjunto de funciones que nos permite ejecutar operaciones o bucles de manera más eficiente dentro de data.frames, matrices, listas o vectores. Estas funciones recorren cada elemento de una fila o una columna, según le hayamos indicado, y ejecuta la función requerida, devolviendo listas o vectores según la función apply aplicada. 10.1 lapply La función lapply() recorre una lista o un vector X y devuelve una lista con el resultado de F(x) para cada elemento. v&lt;- c(1,2,3,4,5) potencia&lt;- lapply(v,function(x) x^2) potencia #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 4 #&gt; #&gt; [[3]] #&gt; [1] 9 #&gt; #&gt; [[4]] #&gt; [1] 16 #&gt; #&gt; [[5]] #&gt; [1] 25 Observa los resultados obtenidos, esta presentación no la hemos visto antes, los resultados de lapply se organizaron en una lista, una lista es otro tipo de organización de datos. 10.2 sapply La función sapply() recorre una lista o un vector X y devuelve un vector con el resultado de F(x) para cada elemento. v&lt;- c(1,2,3,4,5) potencia&lt;- sapply(v,function(x) x^2) potencia #&gt; [1] 1 4 9 16 25 10.3 Practiquemos #Funcion lapply library(quantmod) AANG&lt;- c(&#39;AMZN&#39;,&#39;AAPL&#39;,&#39;NFLX&#39;,&#39;GOOG&#39;) calcula_rendimiento&lt;- function(empresas,fecha_inicio,fecha_fin=Sys.Date()){ xts_empresas &lt;- getSymbols(empresas,src=&#39;yahoo&#39;,from=fecha_inicio, to=fecha_fin, auto.assign = F) df_empresas&lt;- as.data.frame(xts_empresas) precio_apertura&lt;- df_empresas[1,1] precio_actual&lt;- df_empresas[nrow(df_empresas),6] rendimiento&lt;- (precio_actual/precio_apertura)*100 rendimiento } l_rendimiento= lapply(AANG,calcula_rendimiento,&#39;2020-01-01&#39;,&#39;2020-12-31&#39;) l_rendimiento #&gt; [[1]] #&gt; [1] 175.2453 #&gt; #&gt; [[2]] #&gt; [1] 176.7522 #&gt; #&gt; [[3]] #&gt; [1] 160.8678 #&gt; #&gt; [[4]] #&gt; [1] 129.3473 # Elijamos el mejor # unlist, convierte la lista en vector # recuerdas ¿qué hacía which? AANG[which.max(unlist(l_rendimiento))] #&gt; [1] &quot;AAPL&quot; Haremos lo mismo con sapply. La F(x) a emplear será la misma que codificamos en la sección de lapply, por lo que solo tendremos que emplear la función sapply v_rendimiento=sapply(AANG,calcula_rendimiento,&#39;2020-01-01&#39;,&#39;2020-12-31&#39;) v_rendimiento #&gt; AMZN AAPL NFLX GOOG #&gt; 175.2453 176.7521 160.8678 129.3473 names(v_rendimiento[which.max(v_rendimiento)]) #&gt; [1] &quot;AAPL&quot; ¿ Te diste cuenta que fue lo que omitimos al emplear las funciones apply? 10.4 apply La función aplly recorre un array, matriz o data frame y devuelve un vector para cada elemento con el resultado de F(x) a lo largo de la coordenada indicada. En el argumento debemos colocar tres requerimeintos: La matriz, array o data frame a analizar el sentido de la operación (MARGIN = 1 hará la opearción por filas, MARGIN = 2 hará la opearción por columnas) La función a ejecutar Para el ejemplo de aplicación calcularemos el índice de masa corporal de algunos Superhéroes # Armemos el Data Frame df_superheroes&lt;- data.frame(Nombre= c(&quot;Batman&quot;,&quot;Superman&quot;,&quot;Wonder Woman&quot;, &quot;Iron Man&quot;, &quot;Capitana Marvel&quot;, &quot;Capitán América&quot;), Peso= c(95,107,75,102,56.25,108), Estatura=c(1.87,1.90,1.83,1.85,1.80,1.87), Editorial= c(&quot;DC&quot;,&quot;DC&quot;,&quot;DC&quot;,&quot;Marvel&quot;,&quot;Marvel&quot;,&quot;Marvel&quot;)) #Calcular IMC calcula_metros&lt;- function(row){ altura&lt;- as.numeric(row[&#39;Estatura&#39;]) peso&lt;- as.numeric(row[&#39;Peso&#39;]) imc&lt;-round(peso/altura^2,1) val&lt;- ifelse(imc&lt;18.5,&#39;Bajo Peso&#39;, ifelse(imc&lt;25,&#39;Normal&#39;, ifelse(imc&lt;30,&#39;Sobrepeso&#39;,&#39;Obesidad&#39;))) return(c(imc=imc,observaciones=val)) } (imc&lt;- apply(df_superheroes,1,calcula_metros)) #&gt; [,1] [,2] [,3] [,4] #&gt; imc &quot;27.2&quot; &quot;29.6&quot; &quot;22.4&quot; &quot;29.8&quot; #&gt; observaciones &quot;Sobrepeso&quot; &quot;Sobrepeso&quot; &quot;Normal&quot; &quot;Sobrepeso&quot; #&gt; [,5] [,6] #&gt; imc &quot;17.4&quot; &quot;30.9&quot; #&gt; observaciones &quot;Bajo Peso&quot; &quot;Obesidad&quot; (df_superheroes_imc&lt;- cbind(df_superheroes,t(imc))) #&gt; Nombre Peso Estatura Editorial imc #&gt; 1 Batman 95.00 1.87 DC 27.2 #&gt; 2 Superman 107.00 1.90 DC 29.6 #&gt; 3 Wonder Woman 75.00 1.83 DC 22.4 #&gt; 4 Iron Man 102.00 1.85 Marvel 29.8 #&gt; 5 Capitana Marvel 56.25 1.80 Marvel 17.4 #&gt; 6 Capitán América 108.00 1.87 Marvel 30.9 #&gt; observaciones #&gt; 1 Sobrepeso #&gt; 2 Sobrepeso #&gt; 3 Normal #&gt; 4 Sobrepeso #&gt; 5 Bajo Peso #&gt; 6 Obesidad # Calcular el peso medio por editorial # split divide el data frame en función de grupos l_superheores&lt;- split(df_superheroes_imc,df_superheroes_imc$Editorial) mean(l_superheores[[&#39;DC&#39;]]$Peso) #&gt; [1] 92.33333 mean(l_superheores[[&#39;Marvel&#39;]]$Peso) #&gt; [1] 88.75 "],["gráficos-con-ggplot-2.html", "Capitulo11 Gráficos con ggplot 2", " Capitulo11 Gráficos con ggplot 2 El diseño de gráficos es un capítulo muy extenso que requiere mucha práctica, sin embargo no es complejo de comprender. Utilizaremos el paquete ggplot2 para construir gráficos. ggplot2 es un sistema para crear gráficos de forma declarativa es decir grafica a través de instrucciones Para el ejemplo utilizaremos la data generada por los organizadores del Octoberfest con respecto al consumo y precios a lo largo de los años de la cerveza y el pollo vendido en el festival. # Descargaremos la data del portal de datos abiertos de Múchin url_oktoberfest&lt;- &quot;https://opendata.muenchen.de/dataset/8d6c8251-7956-4f92-8c96-f79106aab828/resource/e0f664cf-6dd9-4743-bd2b-81a8b18bd1d2/download/oktoberfestgesamt19852022.csv&quot; df_oktoberfest&lt;- read.csv(url_oktoberfest) colnames(df_oktoberfest)&lt;-c(&#39;año&#39;,&#39;duración&#39;,&#39;visitantes_totales&#39;, &#39;visitantes_tag&#39;,&#39;precio_cerveza&#39;, &#39;consumo_cerveza&#39;, &#39;precio_pollo&#39;,&#39;consumo_pollo&#39;) summary(df_oktoberfest) #&gt; año duración visitantes_totales #&gt; Min. :1985 Min. :16.00 Min. :5.500 #&gt; 1st Qu.:1994 1st Qu.:16.00 1st Qu.:6.000 #&gt; Median :2003 Median :16.00 Median :6.400 #&gt; Mean :2003 Mean :16.35 Mean :6.322 #&gt; 3rd Qu.:2012 3rd Qu.:16.00 3rd Qu.:6.500 #&gt; Max. :2023 Max. :18.00 Max. :7.200 #&gt; visitantes_tag precio_cerveza consumo_cerveza #&gt; Min. :329.0 Min. : 3.20 Min. :48698 #&gt; 1st Qu.:369.0 1st Qu.: 4.89 1st Qu.:53807 #&gt; Median :394.0 Median : 6.75 Median :61772 #&gt; Mean :387.1 Mean : 7.25 Mean :62799 #&gt; 3rd Qu.:406.0 3rd Qu.: 9.41 3rd Qu.:71340 #&gt; Max. :444.0 Max. :14.33 Max. :79225 #&gt; precio_pollo consumo_pollo #&gt; Min. : 3.920 Min. :313636 #&gt; 1st Qu.: 5.340 1st Qu.:479610 #&gt; Median : 8.140 Median :509420 #&gt; Mean : 7.988 Mean :560189 #&gt; 3rd Qu.:10.070 3rd Qu.:681242 #&gt; Max. :15.890 Max. :807710 Figémonos en la estructura principal del gráfico: El primer atributo corresponde al data frame de donde se obtendrá la información El segundo atributo es aes() que permite seleccionar las variables a graficar y como presentarlas (a qué eje corresponden) Con los atributos listos ya podemos empezar a agregar capas para formar un gráfico cada vez más complejo. En el ejemplo relacionaremos el año con el precio de la cerveza e incluiremos dos tipos de gráfico, uno de puntos y uno lineal, para crear un gráfico de puntos hemos colocado geom_point y además hemos agregado un color con un código hexagesima, para el gráfico de línea agregamos geom_line y el color en palabras. # Instalaremos y llamaremos a la librería ggplot2 # install.packages(&quot;ggplot2&quot;) #Descomentar para instalar library(ggplot2) ggplot(df_oktoberfest,aes(x=año,y=precio_cerveza))+geom_line(color=&#39;green&#39;)+ geom_point(color=&#39;#c263f9&#39;) Al código anteiror le incluiremos títulos a los ejes, título al gráfico y un tema. Los títulos de los ejes los agregamos con xlab()o ylab() y el título del gráfico con ggtitle(). Finalmente el tema aplicado será theme_bw() que quita el fondo gris por defecto del gráfico. ggplot(df_oktoberfest,aes(x=año,y=precio_cerveza))+geom_line(color=&#39;green&#39;)+ geom_point(color=&#39;#c263f9&#39;)+ xlab(&quot;Año&quot;) + ylab(&quot;Precio Euros&quot;) + ggtitle(&quot;Precio de la Cerveza en el Octoberfest&quot;)+ theme_bw() Ahora grafiquemos en el mismo gráfico el precio del pollo y el precio de la cerveza a lo largo de los años ggplot(df_oktoberfest,aes(x=año))+ geom_line(aes(y=precio_cerveza,color=&#39;cerveza&#39;))+ geom_line(aes(y=precio_pollo,color=&#39;pollo&#39;))+ xlab(&quot;Año&quot;) + ylab(&#39;Precio E&#39;) + ggtitle(&#39;Precio de la Cerveza y el Pollo en el Oktoberfest&#39;)+ theme_bw() Observe que ahora en el aes solo tenemos asignado x = año ya que es la variable en común, y en cada uno de los gráficos declaramos el eje “y”, además estamos indicando que asigne un color a la cervez y un color al pollo. Para nuestro siguiente gráfico vamos a instalar el paquete reshape2 y ocuparemos la función melt() que permite reorganizar y resumir. El primer argumento corresponde al data frame de donde se obtendrá la información id.vars() corresponde a la variable de identificación measure.vars() son las variables de organización # Instalaremos y llamaremos a la librería ggplot2 # install.packages(&quot;reshape2&quot;) #Descomentar para instalar library(reshape2) df_melted&lt;- melt(df_oktoberfest,id.vars=(&#39;año&#39;), measure.vars=c(&#39;precio_pollo&#39;,&#39;precio_cerveza&#39;), variable.name=&#39;tipo&#39;,value.name = &#39;precio&#39;) head(df_melted) #&gt; año tipo precio #&gt; 1 1985 precio_pollo 4.77 #&gt; 2 1986 precio_pollo 3.92 #&gt; 3 1987 precio_pollo 3.98 #&gt; 4 1988 precio_pollo 4.19 #&gt; 5 1989 precio_pollo 4.22 #&gt; 6 1990 precio_pollo 4.47 tail(df_melted) #&gt; año tipo precio #&gt; 69 2016 precio_cerveza 10.57 #&gt; 70 2017 precio_cerveza 10.87 #&gt; 71 2018 precio_cerveza 11.30 #&gt; 72 2019 precio_cerveza 11.71 #&gt; 73 2022 precio_cerveza 13.45 #&gt; 74 2023 precio_cerveza 14.33 Grafiquemos un diagrama de barras que represente tanto el precio de la cerveza como el del pollo. En aes (contenido estético) hemos colocado el año como variable independiente y el precio como varible dependiente. Mire que para graficar columnas tenemos geom_col() y en position = ‘dodge’ es decir que las columnas se graficarán sin espacio entre sí ggplot(df_melted,aes(x=año, y=precio, color=tipo))+ geom_col(position = &#39;dodge&#39;,aes(fill=tipo))+ ylab(&quot;Precio E&quot;) + xlab(&quot;Año&quot;) + ggtitle(&quot;Precio cerveza y pollo en Oktoberfest&quot;) Finalmente haremos un grafico de correlación Primero con la función cor() generaremos correlaciones entre las variables del data frame cr_oktoberfest&lt;- cor(df_oktoberfest) cr_oktoberfest #&gt; año duración visitantes_totales #&gt; año 1.0000000 0.4315849 -0.224676225 #&gt; duración 0.4315849 1.0000000 0.207551671 #&gt; visitantes_totales -0.2246762 0.2075517 1.000000000 #&gt; visitantes_tag -0.4644614 -0.3798716 0.825457655 #&gt; precio_cerveza 0.9873733 0.4514158 -0.172881811 #&gt; consumo_cerveza 0.8918055 0.4178338 0.003398335 #&gt; precio_pollo 0.9720990 0.4861828 -0.167548583 #&gt; consumo_pollo -0.8497377 -0.3206961 0.369291773 #&gt; visitantes_tag precio_cerveza #&gt; año -0.4644614 0.9873733 #&gt; duración -0.3798716 0.4514158 #&gt; visitantes_totales 0.8254577 -0.1728818 #&gt; visitantes_tag 1.0000000 -0.4275875 #&gt; precio_cerveza -0.4275875 1.0000000 #&gt; consumo_cerveza -0.2391642 0.8732945 #&gt; precio_pollo -0.4438951 0.9870883 #&gt; consumo_pollo 0.5353060 -0.8306472 #&gt; consumo_cerveza precio_pollo #&gt; año 0.891805498 0.9720990 #&gt; duración 0.417833780 0.4861828 #&gt; visitantes_totales 0.003398335 -0.1675486 #&gt; visitantes_tag -0.239164239 -0.4438951 #&gt; precio_cerveza 0.873294471 0.9870883 #&gt; consumo_cerveza 1.000000000 0.8617829 #&gt; precio_pollo 0.861782943 1.0000000 #&gt; consumo_pollo -0.645371093 -0.8529126 #&gt; consumo_pollo #&gt; año -0.8497377 #&gt; duración -0.3206961 #&gt; visitantes_totales 0.3692918 #&gt; visitantes_tag 0.5353060 #&gt; precio_cerveza -0.8306472 #&gt; consumo_cerveza -0.6453711 #&gt; precio_pollo -0.8529126 #&gt; consumo_pollo 1.0000000 Ahora organizaremos la data en dos variables que combinen las variables entre ellas. Observa estamos utilizando la función melt() library(reshape2) mlt_cor_oktober&lt;- melt(cr_oktoberfest) tail(mlt_cor_oktober) #&gt; Var1 Var2 value #&gt; 59 visitantes_totales consumo_pollo 0.3692918 #&gt; 60 visitantes_tag consumo_pollo 0.5353060 #&gt; 61 precio_cerveza consumo_pollo -0.8306472 #&gt; 62 consumo_cerveza consumo_pollo -0.6453711 #&gt; 63 precio_pollo consumo_pollo -0.8529126 #&gt; 64 consumo_pollo consumo_pollo 1.0000000 Generemos el gráfico correlacional. Las variables serán la columna Var1 y la columna Var2 del data frame organizado, recuerda que en las dos columnas hay los mismo parámetro; además hemos colocado un color de relleno fill() que dependerá del valor de la correlación. En este gráfico hemos configurado la escala con la función scale_fill_gradient2() en donde definimos el color que representa una correlación alta, media y baja, además de los límites correlacionales. ggplot(data=mlt_cor_oktober,aes(x= Var1, y =Var2, fill= value))+ scale_fill_gradient2(low = &#39;blue&#39;,high =&#39;red&#39;,mid = &#39;white&#39;,midpoint = 0,limit=c(-1,1), name= &quot;Correlación&quot;)+ geom_tile()+ guides(x = guide_axis(angle = 90)) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
